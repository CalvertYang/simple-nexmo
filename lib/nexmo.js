// Generated by CoffeeScript 1.6.3
(function() {
  var http, https, querystring;

  http = require('http');

  https = require('https');

  querystring = require('querystring');

  (function() {
    var Nexmo, _VERSION;
    _VERSION = '1.0.4';
    Nexmo = function() {
      var buyNumber, cancelNumber, getBalance, getNumbers, getPath, getPricing, getTopUp, initialize, log, searchMessage, searchMessageByIds, searchMessagesByRecipient, searchNumbers, searchRejections, sendBinaryMessage, sendErrorResponse, sendMessage, sendRequest, sendTextMessage, sendWapPushMessage, updateDrCallBackUrl, updateMoCallBackUrl, updateNumberCallback, updateSecret, _BASE_URL, _ENDPOINT, _ERROR_MESSAGES, _HEADERS, _apiKey, _apiSecret, _debugMode, _initialized, _useHttps;
      _HEADERS = {
        'Content-Type': 'application/x-www-form-urlencoded',
        'accept': 'application/json'
      };
      _BASE_URL = 'rest.nexmo.com';
      _ENDPOINT = {
        sms: '/sms/json',
        ussd: '/ussd/json',
        tts: '/tts/json',
        accountGetBalance: '/account/get-balance',
        accountPricing: '/account/get-pricing/outbound',
        accountSettings: '/account/settings',
        accountTopUp: '/account/top-up',
        accountNumbers: '/account/numbers',
        numberSearch: '/number/search',
        numberBuy: '/number/buy',
        numberCancel: '/number/cancel',
        numberUpdate: '/number/update',
        searchMessage: '/search/message',
        searchMessages: '/search/messages',
        searchRejections: '/search/rejections'
      };
      _ERROR_MESSAGES = {
        initializeRequired: 'nexmo not initialized, call nexmo.initialize(api_key, api_secret) first before calling any nexmo API',
        keyAndSecretRequired: 'Key and secret cannot be empty',
        invalidTextMessage: 'Invalid text message',
        invalidBody: 'Invalid body value in binary message',
        invalidUdh: 'Invalid udh value in binary message',
        invalidTitle: 'Invalid title in WAP push message',
        invalidUrl: 'Invalid url in WAP push message',
        invalidSender: 'Invalid from address',
        invalidRecipient: 'Invalid to address',
        invalidCountryCode: 'Invalid country code',
        invalidMsisdn: 'Invalid MSISDN passed',
        invalidMessageId: 'Invalid message id(s)',
        tooManyMessageId: 'Too many message id',
        invalidDate: 'Invalid date value',
        invalidNewSecret: 'Invalid new secret',
        invalidCallbackUrl: 'Invalid callback url',
        invalidTransactionId: 'Invalid transaction id'
      };
      _apiKey = '';
      _apiSecret = '';
      _useHttps = false;
      _debugMode = false;
      _initialized = false;
      initialize = function(key, secret, protocol, debug) {
        if (!key || !secret) {
          throw _ERROR_MESSAGES.keyAndSecretRequired;
        }
        _apiKey = key;
        _apiSecret = secret;
        _useHttps = protocol === 'https' ? true : false;
        _debugMode = debug;
        _initialized = true;
      };
      sendTextMessage = function(sender, recipient, message, callback) {
        var options;
        if (!message) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidTextMessage));
        } else {
          options = {
            from: sender,
            to: recipient,
            type: 'unicode',
            text: message
          };
          sendMessage(options, callback);
        }
      };
      sendBinaryMessage = function(sender, recipient, body, udh, callback) {
        var options;
        if (!body) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidBody));
        } else if (!udh) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidUdh));
        } else {
          options = {
            from: sender,
            to: recipient,
            type: 'binary',
            body: body,
            udh: udh
          };
          sendMessage(options, callback);
        }
      };
      sendWapPushMessage = function(sender, recipient, title, url, validity, callback) {
        var options;
        if (!title) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidTitle));
        } else if (!url) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidUrl));
        } else {
          if (typeof validity === 'function') {
            callback = validity;
            validity = 172800000;
          }
          options = {
            from: sender,
            to: recipient,
            type: 'wappush',
            title: title,
            url: encodeURIComponent(url),
            validity: validity
          };
          sendMessage(options, callback);
        }
      };
      getBalance = function(callback) {
        var endpoint;
        endpoint = getPath(_ENDPOINT.accountGetBalance);
        sendRequest(endpoint, callback);
      };
      getPricing = function(countryCode, callback) {
        var endpoint;
        if (!countryCode || countryCode.length !== 2) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidCountryCode));
        } else {
          endpoint = getPath(_ENDPOINT.accountPricing) + '&country=' + countryCode;
          sendRequest(endpoint, callback);
        }
      };
      updateSecret = function(newSecret, callback) {
        var endpoint;
        if (!newSecret || newSecret.length > 8) {
          sendError(callback, new Error(_ERROR_MESSAGES.invalidNewSecret));
        } else {
          endpoint = getPath(_ENDPOINT.accountSettings) + '&newSecret=' + encodeURIComponent(newSecret);
          sendRequest(endpoint, 'POST', callback);
        }
      };
      updateMoCallBackUrl = function(newUrl, callback) {
        var endpoint;
        if (!newUrl) {
          sendError(callback, new Error(_ERROR_MESSAGES.invalidCallbackUrl));
        } else {
          endpoint = getPath(_ENDPOINT.accountSettings) + '&moCallBackUrl=' + encodeURIComponent(newUrl);
          sendRequest(endpoint, 'POST', callback);
        }
      };
      updateDrCallBackUrl = function(newUrl, callback) {
        var endpoint;
        if (!newUrl) {
          sendError(callback, new Error(_ERROR_MESSAGES.invalidCallbackUrl));
        } else {
          endpoint = getPath(_ENDPOINT.accountSettings) + '&drCallBackUrl=' + encodeURIComponent(newUrl);
          sendRequest(endpoint, 'POST', callback);
        }
      };
      getTopUp = function(transactionId, callback) {
        var endpoint;
        if (!transactionId) {
          sendError(callback, new Error(_ERROR_MESSAGES.invalidTransactionId));
        } else {
          endpoint = getPath(_ENDPOINT.accountTopUp) + '&trx=' + transactionId;
          sendRequest(endpoint, 'POST', callback);
        }
      };
      getNumbers = function(callback) {
        var endpoint;
        endpoint = getPath(_ENDPOINT.accountNumbers);
        sendRequest(endpoint, callback);
      };
      searchNumbers = function(countryCode, pattern, index, size, callback) {
        var endpoint;
        if (!countryCode || countryCode.length !== 2) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidCountryCode));
        } else {
          endpoint = getPath(_ENDPOINT.numberSearch) + '&country=' + countryCode;
          if (typeof pattern === 'function') {
            callback = pattern;
          } else {
            endpoint += '&pattern=' + pattern;
            if (typeof index === 'function') {
              callback = index;
            } else {
              endpoint += '&index=' + index;
              if (typeof size === 'function') {
                callback = size;
              } else {
                endpoint += '&size=' + size;
              }
            }
          }
          sendRequest(endpoint, callback);
        }
      };
      buyNumber = function(countryCode, msisdn, callback) {
        var endpoint;
        if (!countryCode || countryCode.length !== 2) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidCountryCode));
        } else if (!msisdn || msisdn.length < 10) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidMsisdn));
        } else {
          endpoint = getPath(_ENDPOINT.numberBuy) + '&country=' + countryCode + '&msisdn=' + msisdn;
          sendRequest(endpoint, 'POST', callback);
        }
      };
      cancelNumber = function(countryCode, msisdn, callback) {
        var endpoint;
        if (!countryCode || countryCode.length !== 2) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidCountryCode));
        } else if (!msisdn || msisdn.length < 10) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidMsisdn));
        } else {
          endpoint = getPath(_ENDPOINT.numberCancel) + '&country=' + countryCode + '&msisdn=' + msisdn;
          sendRequest(endpoint, 'POST', callback);
        }
      };
      updateNumberCallback = function(countryCode, msisdn, newUrl, sysType, callback) {
        throw 'Not yet implemented!';
      };
      searchMessage = function(messageId, callback) {
        var endpoint;
        if (!messageId) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidMessageId));
        } else {
          endpoint = getPath(_ENDPOINT.searchMessage) + '&id=' + messageId;
          sendRequest(endpoint, callback);
        }
      };
      searchMessageByIds = function(messageIds, callback) {
        var endpoint, id, idLength, idx, _i, _len;
        if (!messageIds || messageIds.length === 0) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidMessageId));
        } else {
          if (messageIds.length > 10) {
            sendErrorResponse(callback, new Error(_ERROR_MESSAGES.tooManyMessageId));
          } else {
            endpoint = getPath(_ENDPOINT.searchMessages) + '&';
            idLength = messageIds.length;
            for (idx = _i = 0, _len = messageIds.length; _i < _len; idx = ++_i) {
              id = messageIds[idx];
              endpoint += 'ids=' + id;
              if (idx < idLength - 1) {
                endpoint += '&';
              }
            }
            sendRequest(endpoint, callback);
          }
        }
      };
      searchMessagesByRecipient = function(date, to, callback) {
        var endpoint;
        if (!date) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidDate));
        } else if (!to) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidRecipient));
        } else {
          endpoint = getPath(_ENDPOINT.searchMessages) + '&date=' + date + '&to=' + to;
          sendRequest(endpoint, callback);
        }
      };
      searchRejections = function(date, to, callback) {
        var endpoint;
        if (!date) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidDate));
        } else {
          endpoint = getPath(_ENDPOINT.searchRejections) + '&date=' + date;
          if (typeof to === 'function') {
            callback = to;
          } else if (to) {
            endpoint += '&to=' + to;
          }
          sendRequest(endpoint, callback);
        }
      };
      sendMessage = function(data, callback) {
        var endpoint;
        if (!data.from) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidSender));
        } else if (!data.to) {
          sendErrorResponse(callback, new Error(_ERROR_MESSAGES.invalidRecipient));
        } else {
          endpoint = getPath(_ENDPOINT.sms) + '&' + querystring.stringify(data);
          log('Sending message from ' + data.from + ' to ' + data.to + ' with message ' + data.text);
          sendRequest(endpoint, 'POST', function(err, apiResponse) {
            if (!err && apiResponse.status && apiResponse.messages[0].status > 0) {
              sendErrorResponse(callback, new Error(apiResponse.messages[0]['error-text'], apiResponse));
            } else {
              if (callback) {
                callback(err, apiResponse);
              }
            }
          });
        }
      };
      sendRequest = function(path, method, callback) {
        var buffer, options, request;
        if (!_initialized) {
          throw _ERROR_MESSAGES.initializeRequired;
        }
        if (typeof method === 'function') {
          callback = method;
          method = 'GET';
        }
        options = {
          host: _BASE_URL,
          port: 80,
          path: path,
          method: method,
          headers: _HEADERS
        };
        log(options);
        if (_useHttps) {
          options.port = 443;
          request = https.request(options);
        } else {
          request = http.request(options);
        }
        request.end();
        buffer = '';
        request.on('response', function(response) {
          response.setEncoding('utf8');
          response.on('data', function(chunk) {
            buffer += chunk;
          });
          response.on('end', function() {
            var err, parserError, responseData;
            log('response ended');
            if (callback) {
              err = null;
              try {
                responseData = JSON.parse(buffer);
              } catch (_error) {
                parserError = _error;
                log(parserError);
                log('could not convert API response to JSON, above error is ignored and raw API response is returned to client');
                err = parserError;
              }
              callback(err, responseData);
            }
          });
          response.on('close', function(e) {
            log('problem with API request detailed stacktrace below ');
            log(e);
            callback(e);
          });
        });
        request.on('error', function(e) {
          log('problem with API request detailed stacktrace below ');
          log(e);
          callback(e);
        });
      };
      getPath = function(action) {
        var credentials;
        credentials = {
          api_key: _apiKey,
          api_secret: _apiSecret
        };
        return action + '?' + querystring.stringify(credentials);
      };
      sendErrorResponse = function(callback, err, returnData) {
        if (callback) {
          callback(err, returnData);
        } else {
          throw err;
        }
      };
      log = function(message) {
        if (message instanceof Error) {
          console.log(message.stack);
        }
        if (_debugMode) {
          if (typeof message === 'object') {
            console.dir(message);
          } else {
            console.log(message);
          }
        }
      };
      return {
        VERSION: _VERSION,
        init: initialize,
        sendTextMessage: sendTextMessage,
        sendBinaryMessage: sendBinaryMessage,
        sendWapPushMessage: sendWapPushMessage,
        getBalance: getBalance,
        getPricing: getPricing,
        updateSecret: updateSecret,
        updateMoCallBackUrl: updateMoCallBackUrl,
        updateDrCallBackUrl: updateDrCallBackUrl,
        getTopUp: getTopUp,
        getNumbers: getNumbers,
        searchNumbers: searchNumbers,
        buyNumber: buyNumber,
        cancelNumber: cancelNumber,
        updateNumberCallback: updateNumberCallback,
        searchMessage: searchMessage,
        searchMessageByIds: searchMessageByIds,
        searchMessagesByRecipient: searchMessagesByRecipient,
        searchRejections: searchRejections
      };
    };
    return module.exports = Nexmo;
  })();

}).call(this);
